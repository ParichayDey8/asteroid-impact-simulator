<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Asteroid Impact Prediction</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    body, html {
      margin: 0; padding: 0; height: 100%;
      font-family: Arial, sans-serif;
    }
    #map {
      width: 100%;
      height: 60vh;
    }
    #info {
      padding: 10px;
      max-height: 35vh;
      overflow-y: auto;
    }
    .asteroid {
      border-bottom: 1px solid #ccc;
      padding: 5px 0;
    }
  </style>
</head>
<body>
  <h1>Asteroid Impact Prediction</h1>
  <div id="map"></div>
  <div id="info"></div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script>
    const NASA_API_KEY = '6gUBCuaOLEW0t62PGKBZA5eXmEdPob8FZOjMJQGT';
    const MAPBOX_TOKEN = 'pk.eyJ1IjoicGFyaWNoYXlkZXk4IiwiYSI6ImNtZ2JnNG1maTBneWQya3F1N216eG91a2MifQ.ghYfXANzEpDJC4xJ3hnLhA';

    mapboxgl.accessToken = MAPBOX_TOKEN;

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/outdoors-v12',
      center: [0, 0], // Centered on equator for a natural, global view of rotation
      zoom: 1.2, // Slightly closer zoom to better see the rotation across the globe
      bearing: 0, // Start with no initial rotation for clean, natural spin
      pitch: 0, // Flat equatorial view to emphasize natural axial rotation (like viewing Earth from space)
      projection: 'globe'
    });

    let isRotating = true;
    let animationId;

    function rotateGlobe() {
      if (!isRotating || !map.isStyleLoaded() || map.isMoving()) {
        animationId = requestAnimationFrame(rotateGlobe);
        return;
      }
      
      // Rotate counter-clockwise (negative bearing) to simulate Earth's natural prograde rotation
      // (west to east, as seen from above the North Pole)
      const currentBearing = map.getBearing();
      map.setBearing(currentBearing - 0.2); // Negative for natural direction; adjust speed as needed (0.2 for subtle, realistic feel)
      
      animationId = requestAnimationFrame(rotateGlobe);
    }

    map.on('load', () => {
      map.setFog({
        'color': '#000000',
        'high-color': '#add8e6',
        'horizon-blend': 0.02,
        'space-color': '#000000',
        'star-intensity': 0.0
      });

      // Start natural rotation immediately after full load
      setTimeout(() => {
        rotateGlobe();
      }, 100); // Short delay for stability
    });

    // Stop rotation on mouse click (tap) - allows manual interaction
    map.on('click', () => {
      isRotating = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    });

    // Optional: Resume natural rotation on double-click (uncomment if desired)
    // map.on('dblclick', () => {
    //   isRotating = true;
    //   rotateGlobe();
    // });

    const infoDiv = document.getElementById('info');
    window.markers = [];

    async function fetchAsteroids() {
      const today = new Date();
      const endDate = new Date();
      endDate.setDate(today.getDate() + 7);

      const formatDate = (date) => date.toISOString().split('T')[0];

      const start_date = formatDate(today);
      const end_date = formatDate(endDate);

      const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${start_date}&end_date=${end_date}&api_key=${NASA_API_KEY}`;

      try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.near_earth_objects) {
          displayAsteroids(data.near_earth_objects);
        } else {
          infoDiv.innerHTML = 'No asteroid data available.';
        }
      } catch (error) {
        infoDiv.innerHTML = 'Error fetching asteroid data.';
        console.error(error);
      }
    }

    function displayAsteroids(neoData) {
      infoDiv.innerHTML = '';

      if (window.markers) {
        window.markers.forEach(marker => marker.remove());
      }
      window.markers = [];

      Object.keys(neoData).forEach(date => {
        neoData[date].forEach(asteroid => {
          const name = asteroid.name;
          const diameterMin = asteroid.estimated_diameter.kilometers.estimated_diameter_min.toFixed(3);
          const diameterMax = asteroid.estimated_diameter.kilometers.estimated_diameter_max.toFixed(3);
          const hazardous = asteroid.is_potentially_hazardous_asteroid ? 'Yes' : 'No';

          const approachData = asteroid.close_approach_data[0];
          const approachDate = approachData.close_approach_date;
          const missDistanceKm = parseFloat(approachData.miss_distance.kilometers).toFixed(0);
          const velocityKps = parseFloat(approachData.relative_velocity.kilometers_per_second).toFixed(2);

          const lon = (Math.random() * 360) - 180;
          const lat = (Math.random() * 60) - 30;

          const marker = new mapboxgl.Marker({ color: hazardous === 'Yes' ? 'red' : 'green' })
            .setLngLat([lon, lat])
            .setPopup(new mapboxgl.Popup().setHTML(`
              <strong>${name}</strong><br/>
              Date: ${approachDate}<br/>
              Diameter: ${diameterMin} - ${diameterMax} km<br/>
              Hazardous: ${hazardous}<br/>
              Miss Distance: ${missDistanceKm} km<br/>
              Velocity: ${velocityKps} km/s
            `))
            .addTo(map);

          window.markers.push(marker);

          const asteroidDiv = document.createElement('div');
          asteroidDiv.className = 'asteroid';
          asteroidDiv.innerHTML = `
            <strong>${name}</strong> (Approach: ${approachDate})<br/>
            Diameter: ${diameterMin} - ${diameterMax} km<br/>
            Hazardous: ${hazardous}<br/>
            Miss Distance: ${missDistanceKm} km<br/>
            Velocity: ${velocityKps} km/s
          `;
          infoDiv.appendChild(asteroidDiv);
        });
      });
    }

    fetchAsteroids();
  </script>
</body>
</html>